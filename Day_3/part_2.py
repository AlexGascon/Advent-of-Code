"""--- Part Two ---

As a stress test on the system, the programs here clear the grid and then store
the value 1 in square 1. Then, in the same allocation order as shown above, they
store the sum of the values in all adjacent squares, including diagonals.

So, the first few squares' values are chosen as follows:

    Square 1 starts with the value 1.
    Square 2 has only one adjacent filled square (with value 1), so it also stores 1.
    Square 3 has both of the above squares as neighbors and stores the sum of
     their values, 2.
    Square 4 has all three of the aforementioned squares as neighbors and stores
     the sum of their values, 4.
    Square 5 only has the first and fourth squares as neighbors, so it gets the
     value 5.

Once a square is written, its value does not change. Therefore, the first few squares would receive the following values:

147  142  133  122   59
304    5    4    2   57
330   10    1    1   54
351   11   23   25   26
362  747  806--->   ...

What is the first value written that is larger than your puzzle input?
"""
import numpy as np

"""FOLLOWED APPROACH

We're going to follow a quite unusual approach here. I haven't been able to
come up with a way of calculating the value of the spiral in each tile, so
I've used a different technique: to draw it.

We'll start hardcoding the 3x3 center of the spiral, and from its lower-right
corner we'll advance step by step generating the numbers in each tile. 

The way of indicating which tile is the next will be interactive: we'll use the
keyboard in each iteration. With 'w' we'll go up, with 's' we'll go down,
with 'a' we'll go left and finally, with 'd' we'll go right (yes, it's a
gamer approach). If we press any other key, we won't move.

After each iteration, the current state of the spiral we'll be print on console.
Therefore, the only thing you have to do is to keep moving in the correct
direction until the first number greater than your input appears on screen."""

def get_spiral_value(spiral, row, column):
    """Returns the value corresponding to the tile (row, column) of the spiral.

    This value is generated by summing all the values adjacent to it (including
    the diagonal ones)"""
    return spiral[row - 1, column -1] + spiral[row - 1, column] + spiral[row - 1, column + 1] + \
           spiral[row, column - 1] + spiral[row, column + 1] + \
           spiral[row + 1, column - 1] + spiral[row + 1, column] + spiral[row + 1, column + 1]


if __name__ == '__main__':
    spiral_size = 11
    spiral = np.array([[0] * spiral_size] * spiral_size)

    # Hardcoding the center of the spiral
    min_center = (spiral_size - 1) / 2 - 1
    max_center = (spiral_size - 1) / 2 + 2
    spiral[min_center:max_center, min_center:max_center]  = \
        [[5, 4, 2], [10, 1, 1], [11, 23, 25]]

    # Setting the start position
    row, column = (max_center - 1, max_center - 1)

    # Creating a dictionary with lambdas to increase/decrease current row/column
    # To use it, we'll call the dictionary passing the input key as the key, and
    # then pass the current row and columns as function arguments.
    # Example: modify_position['w'](2, 3) == (1, 3)
    modify_position = {
        'w': lambda row, col: (row - 1, col),
        's': lambda row, col: (row + 1, col),
        'd': lambda row, col: (row, col + 1),
        'a': lambda row, col: (row, col - 1),
    }
    while True:
        print(spiral)

        # NOTE: If you use Python 3, substitute 'raw_input' with 'input'
        key = raw_input("Choose in which direction you want to advance\n")
        row, column = modify_position[key](row, column)

        value = get_spiral_value(spiral, row, column)
        spiral[row, column] = value
